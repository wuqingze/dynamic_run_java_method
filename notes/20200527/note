首先我可以切确获得方法，假如是原型和原型类的相同，也不是我这边的错，

是方法设计者那边的错，因为语义上Java中原型和原型对象就是表示一样东西，

所以方法开发不应该定义两个函数名一样，一个是int参数，一个是Integer参数，

然后奢望这两个方法不同。



基于上诉的思考，我可以把int和Integer当作一样东西进行处理，这样就很trick的避免

了spring 不体统primitive定义的问题了。



解决不了问题就当作没有发生。



经过测试，如果是Integer类型，被传入int的方法，那么jvm是会自动插箱成int类型的，

所以不必要当心spring调用方法传入对象类型而引发报错。



java反射只会关心第一层的类定义，像反省只会被忽略掉的



spring xml注解里面如果没有特别指定类型的话，默认会设置为string
